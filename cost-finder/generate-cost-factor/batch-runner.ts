import { mkdirSync, writeFileSync } from "node:fs";

import {
  chunkArray,
  colorLabel,
  colorValue,
  COST_DATA_SOURCE_ID,
  DEFAULT_UNITS,
  formatError,
  formatInfo,
  formatSuccess,
  formatWarning,
  LLM_CACHE_PATH,
  OUTPUT_DIR,
  PROGRESS_LOG_PATH,
  UNDO_SQL_PATH,
} from "./config";
import type { ScriptArgs } from "./config";
import {
  fetchTargets,
  loadExistingCostDataPoints,
  loadProcessedTargetKeys,
  makeTargetKey,
  prisma,
  recordProcessedTarget,
} from "./data";
import { getCostEstimate } from "./llm";

function escapeSqlLiteral(value: string): string {
  return value.replace(/'/g, "''");
}

export async function runBatches(args: ScriptArgs): Promise<void> {
  const allTargets = await fetchTargets();
  if (allTargets.length === 0) {
    console.log(formatWarning("No ingredient/location pairs found."));
    return;
  }

  const processedKeys = loadProcessedTargetKeys();
  if (!args.dryRun && processedKeys.size > 0) {
    console.log(
      `${formatInfo("Skipping previously processed ing-loc pairs")}: ${colorValue(String(processedKeys.size))}`
    );
  }

  const availableTargets = args.dryRun
    ? allTargets
    : allTargets.filter((target) => !processedKeys.has(makeTargetKey(target)));

  if (availableTargets.length === 0) {
    console.log(
      formatWarning(
        "All ingredient/location pairs have already been processed according to the progress log."
      )
    );
    return;
  }

  const runLimit = args.limit ?? args.batchSize ?? undefined;
  const limitedTargets = runLimit ? availableTargets.slice(0, runLimit) : availableTargets;
  console.log(
    `${formatInfo("Ingredient/location pairs to process this run")}: ${colorValue(String(limitedTargets.length))}`
  );

  const batchSize = args.batchSize ?? limitedTargets.length;
  const batches = chunkArray(limitedTargets, batchSize);

  const existingMap = await loadExistingCostDataPoints(limitedTargets);
  const undoStatements = ["-- Undo statements generated by generate-cost-factor script", "BEGIN;"];

  let processed = 0;
  let created = 0;
  let retired = 0;
  let failures = 0;
  let terminatedEarly = false;

  for (let batchIndex = 0; batchIndex < batches.length; batchIndex += 1) {
    const batch = batches[batchIndex];
    console.log(
      `${formatInfo(`Starting batch ${batchIndex + 1}/${batches.length}`)} (${colorValue(String(batch.length))} ing-loc pairs)`
    );
    let batchFailed = false;

    for (const target of batch) {
      processed += 1;
      console.log(
        `${formatInfo("Processing")} ${colorValue(target.ingredientName)} ${colorLabel(`(${target.locationName})`)} ${colorValue(`[${processed}/${limitedTargets.length}]`)}`
      );
      try {
        const { response: llmResponse, fromCache } = await getCostEstimate(target);
        if (fromCache) {
          console.log(
            `${formatInfo("Using cached LLM response for")} ${colorValue(target.ingredientName)} ${colorLabel(`(${target.locationCode})`)}`
          );
        }

        const metadata = llmResponse;
        const retireCandidates = (existingMap.get(makeTargetKey(target)) ?? []).filter(
          (record) => record.year === target.year
        );

        if (args.dryRun) {
          const _qualityDetails = {
            breakdown: metadata.qualityBreakdown ?? {},
            band: metadata.qualityBand ?? null,
            qualityScore: metadata.qualityScore,
            derivationType: metadata.derivationType ?? null,
            geoProximity: metadata.geoProximity ?? null,
            sources: metadata.sources ?? [],
          };
          console.log(
            [
              formatWarning("[DRY RUN] Proposed cost factor:"),
              `  ${colorLabel("USD/weight unit")}: ${colorValue(metadata.costInUSD.toFixed(4))}`,
              `  ${colorLabel(`Local currency (${metadata.localCurrencyCode}) per weight unit`)}: ${colorValue((metadata.costInLocalCurrency ?? 0).toFixed(4))}`,
              `  ${colorLabel("Weight units")}: ${metadata.weightUnits}`,
              `  ${colorLabel("Sources")}: ${JSON.stringify(metadata.sources)}`,
              `  ${colorLabel("Quality score")}: ${colorValue(String(metadata.qualityScore))}`,
              `  ${colorLabel("Quality band")}: ${colorValue(String(metadata.qualityBand ?? "N/A"))}`,
              `  ${colorLabel("Quality breakdown")}: ${colorValue(JSON.stringify(metadata.qualityBreakdown ?? {}))}`,
              // `  ${colorLabel("Quality details JSON")}: \n${JSON.stringify(qualityDetails, null, 2)}`,
              `  ${colorLabel("Score justification")}: ${metadata.scoreJustification}`,
              `  ${colorLabel("Explanation")}: ${metadata.explanation?.reasoningAndMethodology}`,
              `  ${colorLabel("Assumptions")}: ${metadata.explanation?.assumptions ?? "N/A"}`,
              `  ${colorLabel("Date")}: ${metadata.date ?? "N/A"}`,
              `  ${colorLabel("Is inferred")}: ${metadata.isInferred}`,
              `  ${colorLabel("Existing entries to retire")}: ${colorValue(String(retireCandidates.length))}`,
            ].join("\n")
          );
          continue;
        }

        const inserted = await prisma.$transaction(async (tx) => {
          const now = new Date();
          for (const existing of retireCandidates) {
            await tx.costDataPoint.update({
              where: { costDataPointId: existing.costDataPointId },
              data: { deleted: true, deletedAt: now },
            });
            undoStatements.push(
              `UPDATE "CostDataPoint" SET "deleted" = false, "deletedAt" = NULL WHERE "costDataPointId" = '${escapeSqlLiteral(existing.costDataPointId)}';`
            );
          }
          const createdRecord = await tx.costDataPoint.create({
            data: {
              ingredientMetadataId: target.ingredientMetadataId,
              locationCode: target.locationCode,
              year: target.year,
              costDataSourceId: COST_DATA_SOURCE_ID,
              factor: metadata.costInUSD,
              units: DEFAULT_UNITS,
              notes: null,
              // AI metadata is stored in the LLM cache, not in the database
            },
          });
          undoStatements.push(
            `DELETE FROM "CostDataPoint" WHERE "costDataPointId" = '${escapeSqlLiteral(createdRecord.costDataPointId)}';`
          );
          return { createdRecord };
        });

        created += 1;
        retired += retireCandidates.length;
        recordProcessedTarget(target, inserted.createdRecord.costDataPointId);
        const _qualityDetails = {
          breakdown: metadata.qualityBreakdown ?? {},
          band: metadata.qualityBand ?? null,
          qualityScore: metadata.qualityScore,
          derivationType: metadata.derivationType ?? null,
          geoProximity: metadata.geoProximity ?? null,
          sources: metadata.sources ?? [],
        };
        console.log(
          [
            formatSuccess(`Created CostDataPoint ${inserted.createdRecord.costDataPointId}`),
            `  ${colorLabel("Factor (USD/kg)")}: ${colorValue(metadata.costInUSD.toFixed(4))}`,
            `  ${colorLabel(`Local currency (${metadata.localCurrencyCode}) per kg`)}: ${colorValue((metadata.costInLocalCurrency ?? 0).toFixed(4))}`,
            `  ${colorLabel("Sources")}: ${JSON.stringify(metadata.sources)}`,
            `  ${colorLabel("Quality score")}: ${colorValue(String(metadata.qualityScore))} (${metadata.qualityBand ?? "N/A"})`,
            `  ${colorLabel("Quality breakdown")}: ${colorValue(JSON.stringify(metadata.qualityBreakdown ?? {}))}`,
            // `  ${colorLabel("Quality details JSON")}: \n${JSON.stringify(qualityDetails, null, 2)}`,
          ].join("\n")
        );
      } catch (error) {
        failures += 1;
        batchFailed = true;
        console.error(
          formatError(
            `Failed to process ${target.ingredientName} (${target.locationName}). See details below.`
          ),
          error
        );
        break;
      }
    }

    if (batchFailed) {
      terminatedEarly = true;
      console.log(
        formatWarning(
          `Terminating after batch ${batchIndex + 1} due to errors. Rerun the script to continue from the next ing-loc pair.`
        )
      );
      break;
    }
  }

  if (!args.dryRun) {
    undoStatements.push("COMMIT;");
    // eslint-disable-next-line security/detect-non-literal-fs-filename
    mkdirSync(OUTPUT_DIR, { recursive: true });
    // eslint-disable-next-line security/detect-non-literal-fs-filename
    writeFileSync(UNDO_SQL_PATH, undoStatements.join("\n") + "\n", "utf8");
    console.log(`${formatInfo("Undo SQL written to")}: ${colorValue(UNDO_SQL_PATH)}`);
    console.log(`${formatInfo("Progress log")}: ${colorValue(PROGRESS_LOG_PATH)}`);
    console.log(`${formatInfo("LLM cache")}: ${colorValue(LLM_CACHE_PATH)}`);
  }

  console.log(
    [
      terminatedEarly
        ? formatWarning("Processing stopped early due to errors.")
        : formatSuccess("Processing complete."),
      `  ${colorLabel("Targets attempted")}: ${colorValue(String(processed))}`,
      `  ${colorLabel("Created rows")}: ${colorValue(String(created))}`,
      `  ${colorLabel("Retired rows")}: ${colorValue(String(retired))}`,
      `  ${colorLabel("Failures")}: ${failures > 0 ? formatError(String(failures)) : colorValue(String(failures))}`,
    ].join("\n")
  );
}
